# 820. Short Encoding of Words

## 题

给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。

例如，如果这个列表是 ["time", "me", "bell"]，我们就可以将其表示为 S = "time#bell#" 和 indexes = [0, 2, 5]。

对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 "#" 结束，来恢复我们之前的单词列表。

那么成功对给定单词列表进行编码的最小字符串长度是多少呢？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/short-encoding-of-words

## 解

### 方法一：哈希表删后缀
- 思路：
  - 构造一个包含所有单词的哈希表，对每个单词，在哈希表中删去该单词的所有后缀
- 时间复杂度：
  - o(sum(word_len_i^2))
- 空间复杂度：
  - o(sum(word_len_i))
- 结果:
  - 用时：66%（168ms）
  - 内存：47%
```
class Solution {
public:
    int minimumLengthEncoding(vector<string>& words) {
        unordered_set<string> reduce(words.begin(),words.end());
        for(const string& word:words){
            for(int i=1;i<word.size();i++){
                reduce.erase(word.substr(i));
            }
        }
        int res=0;
        for(const string& word:reduce) res+=word.size()+1;
        return res;
    }
};
```

### 方法二：排序【含改进】
- 思路：
  - 如果一个字符串是另一个字符串的后缀，那么在字典序中，后缀串在原字符串的前一个位置
- 时间复杂度：
  - o(n*max(word_len_i))
- 空间复杂度：
  - o(sum(word_len_i))
  - 改进：o(1)
- 结果:
  - 用时：79%（108ms）
  - 内存：47%
```
class Solution {
public:
    int minimumLengthEncoding(vector<string>& words) {
        vector<string> rwords;
        for(string word:words){
            reverse(word.begin(),word.end()); //sum(len)
            rwords.push_back(word);
        }
        sort(rwords.begin(),rwords.end()); //n*max(len) 基数排序复杂度
        int res=0;
        for(int i=0;i<rwords.size();i++){ //n
            if(i+1<words.size() && rwords[i+1].find(rwords[i])==0) continue; //2*max(len)
            res+=rwords[i].size()+1;
        }
        return res;
    }
};
改进：class Solution {
    static bool cmp(string& a,string& b){
        int sa=a.size(),sb=b.size();
        for(int i=0;i<min(sa,sb);i++){
            char ca=a[sa-1-i],cb=b[sb-1-i];
            if(ca!=cb) return ca<cb;
        }
        return sa<sb;
    }
public:
    int minimumLengthEncoding(vector<string>& words) {
        sort(words.begin(),words.end(),cmp);
        int res=0;
        for(int i=0;i<words.size();i++){
            if(i+1<words.size() && words[i+1].find(words[i])!=words[i+1].npos && words[i+1].find(words[i])==words[i+1].size()-words[i].size()) continue;
            res+=words[i].size()+1;
        }
        return res;
    }
};
```

### 方法三：字典树
- 思路：
  - [content]
- 时间复杂度：
  - [content]
- 空间复杂度：
  - [content]
- 结果:
  - 用时：%（ms）
  - 内存：%
```
[`code`]
```

## 记

- (@memony)[字典树](https://leetcode-cn.com/problems/short-encoding-of-words/solution/shou-si-zi-dian-shu-trie-shu-c-by-time-limit/)：
  - 
- 2020.03.28 by lorwin