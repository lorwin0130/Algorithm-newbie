# 912. Sort an Array

## 题

排序

## 解

### 方法一：冒泡排序
- 时间复杂度：
  - o(n^2)
- 空间复杂度：
  - o(1)
- 稳定性：
  - 稳定
```
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        for(int i=nums.size()-2;i>=0;i--){
            bool is_swap=false;
            for(int j=0;j<=i;j++){
                if(nums[j]>nums[j+1]){
                    swap(nums[j],nums[j+1]);
                    is_swap=true;
                }
            }
            if(!is_swap) break;
        }
        return nums;
    }
};
```

### 方法二：快速排序
- 时间复杂度：
  - o()
- 空间复杂度：
  - o()
- 稳定性：
  - 稳定？
```
class Solution {
    int quick_partition(vector<int>& nums, int l, int r){
        //设定枢纽元素
        int& key=nums[r];
        //双指针遍历，左边找大值，右边找小值，交换，直到指针相遇
        while(l<r){
            while(l<r && nums[l]<=key) l++;
            while(l<r && nums[r]>=key) r--;
            swap(nums[l], nums[r]);
        }
        //将枢纽元素归位
        swap(nums[l], key);
        //返回枢纽元素的索引
        return l;
    }
    void quick_sort(vector<int>& nums, int l, int r){  //递归版本
        //递归出口
        if(l>=r) return;
        //计算划分边界
        int p=quick_partition(nums, l, r);
        //分别递归
        quick_sort(nums, l, p-1);
        quick_sort(nums, p+1, r);
    }
    void quick_sort(vector<int>& nums, int l, int r){   //非递归版本
        //新建栈
        stack<int> s;
        //初始化
        s.push(l);
        s.push(r);
        //栈非空时循环，弹出该问题信息，如果不是递归出口，则计算划分边界，将子问题的信息压入栈中
        while(!s.empty()){
            int right=s.top(); s.pop();
            int left=s.top(); s.pop();
            if(left<right){
                int p=quick_partition(nums, left, right);
                s.push(left);
                s.push(p-1);
                s.push(p+1);
                s.push(right);
            }
        }
    }
public:
    vector<int> sortArray(vector<int>& nums) {
        quick_sort(nums, 0, nums.size()-1);
        return nums;
    }
};
```

### 方法三：
- 时间复杂度：
  - o()
- 空间复杂度：
  - o()
- 稳定性：
  - 稳定？
```
code
```

### 方法四：
- 时间复杂度：
  - o()
- 空间复杂度：
  - o()
- 稳定性：
  - 稳定？
```
code
```

### 方法五：
- 时间复杂度：
  - o()
- 空间复杂度：
  - o()
- 稳定性：
  - 稳定？
```
code
```

## 记

- 2020.03.31 by lorwin