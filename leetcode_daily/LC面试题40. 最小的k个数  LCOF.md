# 面试题40. 最小的k个数  LCOF

## 题

输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

## 解

### 方法一：
- 思路：
  - 排序（升序），返回前k个
- 时间复杂度：
  - o(nlogn)
- 空间复杂度：
  - o(1)
- 结果:
  - 用时：53%（48ms）
  - 内存：100%
```
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        sort(arr.begin(),arr.end());
        return vector<int>(arr.begin(),arr.begin()+k);
    }
};
```

### 方法二：大顶堆（参考题解）
- 思路：
  - 利用优先队列（大顶堆），来维持前k个小值
- 时间复杂度：
  - o(nlogk)
- 空间复杂度：
  - o(k)
- 结果:
  - 用时：25%（68ms）
  - 内存：100%
```
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        vector<int> res;
        if(k==0) return res;
        priority_queue<int> q;
        for(int i=0;i<k;i++) q.push(arr[i]);
        for(int i=k;i<arr.size();i++){
            if(q.top()>arr[i]){
                q.pop();
                q.push(arr[i]);
            }
        }
        for(int i=0;i<k;i++){
            res.push_back(q.top());
            q.pop();
        }
        return res;
    }
};
```

### 方法三：快排思想
- 思路：
  - 单次分割数组
    - 将区域中比枢纽小的，全部交换到左边
  - 随机选择枢纽
    - 随机选择所选区域中的一个随机元素
  - 递归分割
    - 根据分割的位置，确定下一个操作的分段，直到分出k个小值
- 时间复杂度：
  - o(n)
- 空间复杂度：
  - o(logn)
- 结果:
  - 用时：96%（24ms）
  - 内存：100%
```
class Solution {
    int partition(vector<int>& arr,int l,int r){
        int pivot=arr[r];
        int i=l-1;
        for(int j=l;j<r;j++){
            if(arr[j]<=pivot) swap(arr[++i],arr[j]);
        }
        swap(arr[++i],arr[r]);
        return i;
    }
    int randomized_selection(vector<int>& arr,int l,int r){
        int p=rand()%(r-l+1)+l;
        swap(arr[p],arr[r]);
        return partition(arr,l,r);
    }
    void randomized_partition(vector<int>& arr,int l,int r,int k){
        if(l>=r) return;
        int pos=randomized_selection(arr,l,r);
        int num=pos-l+1;
        if(num==k) return;
        if(num>k) randomized_partition(arr,l,pos-1,k);
        if(num<k) randomized_partition(arr,pos+1,r,k-num);
    }
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        vector<int> res;
        if(k==0) return res;
        randomized_partition(arr,0,arr.size()-1,k);
        return vector<int>(arr.begin(),arr.begin()+k); 
    }
};
```

## 记

- (@memory)学习方法三的思想
- 快排代码：
  ```

  ```
- 2020.03.20 by lorwin