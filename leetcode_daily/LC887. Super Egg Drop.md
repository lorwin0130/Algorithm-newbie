# 887. Super Egg Drop

## 题

你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/super-egg-drop

## 解

### 方法一：常规dp，超时
- 思路：
  - 动态规划，dp[K][N]表示在有K个鸡蛋，N个层楼的情况下，最小的最坏情况移动次数
  - 状态转移方程：dp[K][N] = 1 + min(max_i(dp[K][N-i], dp[K-1][i-1])), 1<=i<=N
- 时间复杂度：
  - o(K*N^2)
- 空间复杂度：
  - o(K*N),二维dp数组
- 结果:
  - 结果超时
```
class Solution {
    vector<vector<int>> dp;
    int superEggDrop_dp(int K, int N) {
        if(dp[K][N]!=-1) return dp[K][N];
        if(K==1 || N<=2) {dp[K][N]=N; return N;}
        int bin=log(N)/log(2)+1;
        if(K>=bin) {dp[K][N]=bin; return bin;}
        int tmp=N;
        for(int i=1;i<N-1;i++) tmp=min(tmp, max(superEggDrop_dp(K, N-i), superEggDrop_dp(K-1, i-1)));
        dp[K][N]=tmp+1; return tmp+1;
    }
public:
    int superEggDrop(int K, int N) {
        dp=vector<vector<int>>(K+1, vector<int>(N+1, -1));
        return superEggDrop_dp(K, N);
    }
};
```

### 方法二：优化
- 思路：
  - 在确定状态转移的时候，可以不用线性搜索1<=i<=N的所有情况，而是采用二分搜索
- 时间复杂度：
  - o(K*NlogN)
- 空间复杂度：
  - o(K*N)
- 结果:
  - 用时：%（ms）
  - 内存：%
```
[`code`]
```

### 方法三：另类dp，空间o(1)
- 思路：
  - 
- 时间复杂度：
  - o()
- 空间复杂度：
  - o()
- 结果:
  - 用时：%（ms）
  - 内存：%
```
[`code`]
```

## 记

- (@memory)动态规划总结：
  - 常规套路：
    - 
  - 优化点：
    - 
- 2020.04.11 by lorwin